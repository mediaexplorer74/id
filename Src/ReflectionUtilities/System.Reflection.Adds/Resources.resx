<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArrayInsideArrayInAttributeNotSupported" xml:space="preserve">
    <value>Arrays inside other arrays in custom attributes is not supported.</value>
  </data>
  <data name="AssemblyRefTokenExpected" xml:space="preserve">
    <value>Assembly reference token expected.</value>
  </data>
  <data name="UniverseCannotResolveAssembly" xml:space="preserve">
    <value>Type universe cannot resolve assembly: {0}.</value>
  </data>
  <data name="CannotDetermineSystemAssembly" xml:space="preserve">
    <value>Type universe has not selected an assembly as the system assembly.</value>
  </data>
  <data name="CannotFindTypeInModule" xml:space="preserve">
    <value>Cannot find type {0} in module {1}.</value>
  </data>
  <data name="CannotResolveModuleRefOnNetModule" xml:space="preserve">
    <value>Cannot resolve module reference on a single net module.</value>
  </data>
  <data name="CannotResolveRVA" xml:space="preserve">
    <value>Cannot resolve RVA.</value>
  </data>
  <data name="CaseInsensitiveTypeLookupNotImplemented" xml:space="preserve">
    <value>Case insensitive type lookup is not implemented.</value>
  </data>
  <data name="CorruptImage" xml:space="preserve">
    <value>Image is corrupt. Attempting to read an out of range RVA.</value>
  </data>
  <data name="DefaultTokenResolverRequired" xml:space="preserve">
    <value>Without an assembly qualified name, a default token resolver is required.</value>
  </data>
  <data name="DifferentTokenResolverForOuterType" xml:space="preserve">
    <value>Outer type has different token resolver.</value>
  </data>
  <data name="EscapeSequenceMissingCharacter" xml:space="preserve">
    <value>Escape sequence missing character after the backslash.</value>
  </data>
  <data name="ExpectedPositiveNumberOfGenericParameters" xml:space="preserve">
    <value>Expected positive number of generic parameters. </value>
  </data>
  <data name="ExpectedPropertyOrFieldId" xml:space="preserve">
    <value>Expected property or field ID.</value>
  </data>
  <data name="ExpectedTokenType" xml:space="preserve">
    <value>{0} token expected.</value>
  </data>
  <data name="ExtraAssemblyManifest" xml:space="preserve">
    <value>Non-manifest module contains assembly manifest or module is corrupted.</value>
  </data>
  <data name="ExtraCharactersAfterTypeName" xml:space="preserve">
    <value>Extra characters after type name.</value>
  </data>
  <data name="ExtraInformationAfterLastParameter" xml:space="preserve">
    <value>More information left after last parameter is processed.</value>
  </data>
  <data name="HostSpecifierMissing" xml:space="preserve">
    <value>Assembly qualified name requires a host.</value>
  </data>
  <data name="IdTokenTypeExpected" xml:space="preserve">
    <value>Id token type expected.</value>
  </data>
  <data name="IllegalElementType" xml:space="preserve">
    <value>Illegal element type {0}.</value>
  </data>
  <data name="IllegalLayoutMask" xml:space="preserve">
    <value>Illegal layout mask.</value>
  </data>
  <data name="IncorrectElementTypeValue" xml:space="preserve">
    <value>Incorrect core element type value.</value>
  </data>
  <data name="InvalidCustomAttributeFormat" xml:space="preserve">
    <value>Invalid custom attribute format.</value>
  </data>
  <data name="InvalidCustomAttributeFormatForEnum" xml:space="preserve">
    <value>Invalid custom attribute blob. Enum parameters must have full type name specified.</value>
  </data>
  <data name="InvalidElementTypeInAttribute" xml:space="preserve">
    <value>Invalid core element type in custom attribute blob.</value>
  </data>
  <data name="InvalidFileFormat" xml:space="preserve">
    <value>Invalid file format.</value>
  </data>
  <data name="InvalidMetadata" xml:space="preserve">
    <value>Invalid metadata.</value>
  </data>
  <data name="InvalidMetadataSignature" xml:space="preserve">
    <value>Invalid metadata signature.</value>
  </data>
  <data name="InvalidMetadataToken" xml:space="preserve">
    <value>Invalid metadata token {0}.</value>
  </data>
  <data name="InvalidPublicKeyTokenLength" xml:space="preserve">
    <value>Length of public key token must be even.</value>
  </data>
  <data name="JaggedArrayInAttributeNotSupported" xml:space="preserve">
    <value>Jagged array in custom attributes is not supported.</value>
  </data>
  <data name="ManifestModuleMustBeProvided" xml:space="preserve">
    <value>Manifest module must be provided.</value>
  </data>
  <data name="MethodIsUsingUnsupportedBindingFlags" xml:space="preserve">
    <value>{0} is using unsupported binding flags {1}</value>
  </data>
  <data name="MethodTokenExpected" xml:space="preserve">
    <value>Method token expected.</value>
  </data>
  <data name="NoAssemblyManifest" xml:space="preserve">
    <value>Manifest module does not contain assembly manifest or module is corrupted.</value>
  </data>
  <data name="OperationInvalidOnAutoLayoutFields" xml:space="preserve">
    <value>This operation cannot be be applied to RVA fields with auto-layout.</value>
  </data>
  <data name="OperationValidOnArrayTypeOnly" xml:space="preserve">
    <value>This operation is valid on an array type only.</value>
  </data>
  <data name="OperationValidOnEnumOnly" xml:space="preserve">
    <value>This operation is valid on Enum types only.</value>
  </data>
  <data name="OperationValidOnLiteralFieldsOnly" xml:space="preserve">
    <value>This operation can be applied to literal fields only.</value>
  </data>
  <data name="OperationValidOnRVAFieldsOnly" xml:space="preserve">
    <value>This operation is valid on RVA fields only.</value>
  </data>
  <data name="ResolvedAssemblyMustBeWithinSameUniverse" xml:space="preserve">
    <value>Resolved assembly must be within the same universe.</value>
  </data>
  <data name="ResolverMustResolveToValidAssembly" xml:space="preserve">
    <value>Resolver must resolve to a valid assembly.</value>
  </data>
  <data name="ResolverMustResolveToValidModule" xml:space="preserve">
    <value>Resolver must resolve module reference to a valid module.</value>
  </data>
  <data name="ResolverMustSetAssemblyProperty" xml:space="preserve">
    <value>Resolver must set assembly property to this assembly.</value>
  </data>
  <data name="RVAUnsupported" xml:space="preserve">
    <value>This metadata importer doesn't have a base address to resolve RVA address against.</value>
  </data>
  <data name="TypeArgumentCannotBeResolved" xml:space="preserve">
    <value>Type argument cannot be resolved.</value>
  </data>
  <data name="TypeTokenExpected" xml:space="preserve">
    <value>Type token expected.</value>
  </data>
  <data name="UnexpectedCharacterFound" xml:space="preserve">
    <value>Unexpected character found while parsing.</value>
  </data>
  <data name="UnexpectedEndOfInput" xml:space="preserve">
    <value>Unexpected end of input.</value>
  </data>
  <data name="UnrecognizedAssemblyAttribute" xml:space="preserve">
    <value>Unrecognized assembly attribute: {0}.</value>
  </data>
  <data name="UnsupportedExceptionFlags" xml:space="preserve">
    <value>Unsupported exception flags {0}.</value>
  </data>
  <data name="UnsupportedImageType" xml:space="preserve">
    <value>Unsupported image type.</value>
  </data>
  <data name="UnsupportedTypeInAttributeSignature" xml:space="preserve">
    <value>Unsupported type argument in custom attribute signature.</value>
  </data>
  <data name="ValidOnGenericParameterTypeOnly" xml:space="preserve">
    <value>Method may only be called on a Type for which Type.IsGenericParameter is true.</value>
  </data>
  <data name="VarargSignaturesNotImplemented" xml:space="preserve">
    <value>Signatures with variable number of arguments are not implemented.</value>
  </data>
  <data name="VersionAlreadyDefined" xml:space="preserve">
    <value>Version already defined.</value>
  </data>
  <data name="WrongNumberOfGenericArguments" xml:space="preserve">
    <value>Wrong number of generic arguments.</value>
  </data>
  <data name="InvalidFileName" xml:space="preserve">
    <value>Invalid file name: "{0}".</value>
  </data>
  <data name="WindowsRuntimeTypeNotFound" xml:space="preserve">
    <value>Windows runtime type {0} cannot be found</value>
  </data>
</root>